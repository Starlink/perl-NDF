\documentclass[twoside,11pt]{article}

% LaTeX document produced by pod2latex from "NDF.pm.pod".
% The followings need be defined in the preamble of this document:
%\def\C++{{\rm C\kern-.05em\raise.3ex\hbox{\footnotesize ++}}}
\def\underscore{\leavevmode\kern.04em\vbox{\hrule width 0.4em height 0.3pt}}
%\setlength{\parindent}{0pt}


% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {[number].[version]}
\newcommand{\stardocauthors}   {T. Jenness, M. J. Bly}
\newcommand{\stardocdate}      {21 February 1998}
\newcommand{\stardoctitle}     {NDFPERL \\ [2ex] PERL interface to NDF}
\newcommand{\stardocversion}   {Version 1.3}
\newcommand{\stardocmanual}    {}
\newcommand{\stardocabstract}  {[Text of abstract]}
% ? End of document identification

% Some commands for referencing

\newcommand{\task}[1]{{\sf #1}}


\newcommand{\ndf}{\xref{NDF}{sun33}{}}
\newcommand{\hds}{\xref{HDS}{sun92}{}}
\newcommand{\ary}{\xref{ARY}{sun11}{}}
\newcommand{\mers}{\xref{MERS}{sun104}{}}
\newcommand{\Kappa}{\xref{{\sc{Kappa}}}{sun95}{}}

\newcommand{\parget}{\xref{\task{parget}}{sun95}{PARGET}}



% -----------------------------------------------------------------------------

% +
%  Name:
%     sun.tex
%
%  Purpose:
%     Template for Starlink User Note (SUN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     {Add further history here}
%
% -

\newenvironment{myquote}{\begin{quote}\begin{small}}{\end{small}\end{quote}}
\newcommand{\text}[1]{{\small \tt #1}}


\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %\begin{rawtex} and %\end{rawtex} lines (used by 
%  star2html to signify raw TeX that latex2html cannot process).
%\begin{rawtex}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}
%\end{rawtex}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newenvironment{latexonly}{}{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{{\bf LaTeX}{2}{\tt{HTML}}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\newcommand{\latex}[1]{#1}
\newcommand{\setunderscore}{\renewcommand{\_}{{\tt\symbol{95}}}}
\latex{\setunderscore}

%  Redefine the \tableofcontents command. This procrastination is necessary 
%  to stop the automatic creation of a second table of contents page
%  by latex2html.
\newcommand{\latexonlytoc}[0]{\tableofcontents}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
% \renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\sc Rutherford Appleton Laboratory} \hfill {\bf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\bf  \stardoctitle \\ [2.5ex]}
   {\LARGE\bf \stardocversion \\ [4ex]}
%  {\Huge\bf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
%  \vspace{10mm}
%  \begin{center}
%     {\Large\bf Abstract}
%  \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
%     \stardocmanual
   \begin{rawhtml} </H1> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://star-www.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://star-www.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \renewcommand{\latexonlytoc}[0]{}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
% \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
% \stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
% \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \latexonlytoc
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
% \cleardoublepage
% \renewcommand{\thepage}{\arabic{page}}
% \setcounter{page}{1}

\newpage
% ? Main text
\section{\xlabel{introduction}\label{introduction}Introduction}

The extensible N-dimensional data format (NDF) is a format for storing bulk
data in the form of N-dimensional arrays of numbers.  It is typically used
for storing spectra, images and similar datasets with higher dimensionality.
The NDF format is based on the Hierarchical Data System (HDS) and is
extensible; not only does it provide a comprehensive set of standard
ancillary items to describe the data, it can also be extended indefinitely
to handle additional user-defined information of any type.

The NDFPERL module provides a perl interface to the Fortran \ndf, \hds\ and
\mers\ (MSG and ERR) libraries that are supplied with the standard Starlink
software distribution.

This document assumes a basic knowledge of both perl and the Starlink
programming environment.


\section{\xlabel{using_ndfperl}\label{using_ndfperl}Using NDFPERL}

The NDFPERL system consists of a binary \texttt{ndfperl}, typically
installed in \texttt{/star/bin} on Starlink systems, and a module
\texttt{NDF.pm}, typically installed in
\texttt{/star/lib/perl5}.\footnote{Alternatively, it is possible to build a
shared library, \texttt{NDF.so}, instead of a binary in which case the
standard perl binary can be used.  All Starlink distributions include NDFPERL
as a binary because the Digital Unix version of this module must be
built using 32 bit memory addressing whereas most perl installations on these
systems are built with 64 bit addressing.}

The entire \ndf, \hds\ and \mers\ system can be imported into a perl program
by using the \texttt{use} command:

\begin{myquote}
\begin{verbatim}
use NDF;
\end{verbatim}
\end{myquote}

If only a subset of these commands are required then it is possible to supply
the names of the subsystem to the \texttt{use} command:

\begin{myquote}
\begin{verbatim}
use NDF qw(:ndf :misc);
\end{verbatim}
\end{myquote}
would import just the \texttt{ndf\_} and miscellaneous commands into the
namespace. The remaining commands would still be available but must be
accessed through their package name (e.g.\ \texttt{hds\_open} would be
available as \texttt{\&NDF::hds\_open}). The individual subsystems along with
the available commands are listed in appendix \ref{subsys}.

Once the module has been loaded the library subroutines can be accessed 
by using perl commands of the same name. For example, the following could be
used in order to open
and close an NDF file:

\begin{myquote}
\begin{verbatim}
#!/star/bin/ndfperl

use NDF;

$status = &NDF::SAI__OK;   # Initialise good status

ndf_begin;                 # initialise the NDF system

ndf_find(&NDF::DAT__ROOT, 'ndf_test', $indf, $status);
ndf_annul($indf, $status); # Close the file

ndf_end($status);          # Close down NDF
\end{verbatim}
\end{myquote}
Note that the routine names are all in lower case, but apart from this use the 
same syntax that would be used for accessing the Fortran routine.
Section \ref{consts} describes how to access constants such as SAI\_\_OK and
DAT\_\_ROOT.

Example programs are available in the {\tt t} sub-directory of the installation
tree, or on Starlink systems in \texttt{/star/examples/ndfperl}.


\subsection{\xlabel{consts}Access to compiler constants\label{consts}}%
\index{Access to compiler constants}

Occassionally it is necessary to access Starlink system constants dealing with
error status and system limitations.
Compiler constants can be accessed via \&NDF::(constant) and are autoloaded as 
required.
e.g. The value for SAI\underscore{}\underscore{}OK can be accessed as \&NDF::SAI\underscore{}\underscore{}OK, as in:

\begin{myquote}
\begin{verbatim}
ndf_find(&NDF::DAT__ROOT,$filename,$indf,$status);
print "An error occurred\n" if ($status != &NDF::SAI__OK);
\end{verbatim}
\end{myquote}


At present all the DAT\underscore{}\underscore{},
ERR\underscore{}\underscore{}, EMS\underscore{}\underscore{},
MSG\underscore{}\underscore{} and SAI\underscore{}\underscore{} constants are
available. More can be included as more C include files are created.  In the
absence of the necessary include files a request for a specific compiler
constant will be refused.

\subsection{Dealing with MAPPED arrays}%
\index{Dealing with MAPPED arrays}

Routines such as ndf\underscore{}map and dat\underscore{}mapv return pointers
to the data arrays. These pointers are handled differently in perl than in
Fortran.

To read a mapped array you must first {\em copy\/} the data from the mapped
array into a perl array. Modifiying this perl array {\em will not\/} change
the mapped array. The perl array must be copied back into the mapped 
array for any changes to become permanent. To reduce resource requirements
you may want to unmap the array as soon as it has been copied to the 
perl array. Currently there is no way to access the mapped data directly.


In perl the array must first be packed into a single string and this
string must then be copied to the mapped memory location.
For example:

\begin{myquote}
\begin{verbatim}
$mapped_string = pack("i*", @data);
ndf_map($indf, 'DATA', '_INTEGER', 'WRITE', $pntr, $el, $status);
string2mem($mapped_string, 4 * $el, $pntr);
\end{verbatim}
\end{myquote}

This copies a perl data array to the NDF DATA\underscore{}ARRAY. If \$el does
not equal \$\#data + 1 (i.e. the number of entries in the perl array) then odd
things will happen.

The reverse process can be achieved using \texttt{mem2string} as follows:

\begin{myquote}
\begin{verbatim}
ndf_map($indf, 'DATA', '_INTEGER', 'READ', $pntr, $el, $status);
mem2string($pntr, 4 * $el, $mapped_string);
@data = unpack("i*", $mapped_string);
\end{verbatim}
\end{myquote}

Note that both \texttt{mem2string} and \texttt{string2mem} require the {\em
number of bytes\/} to be mapped. The data then has to be unpacked into an
array by the perl \texttt{unpack} command. Obviously for \_REAL data
a different option should be used for \texttt{pack}. For large data arrays
this method is extremely inefficient and use of the \htmladdnormallinkfoot{Perl Data Language (PDL)}{http://www.aao.gov.au/local/www/kgb/perldl/}
should be considered\footnote{A module is available for reading NDF files into
PDL. If PDL::IO::NDF is not available on your system please contact 
the Starlink librarian (ussc\@star.rl.ac.uk) if you are on a Starlink site
or the JACH WWW pages (http://www.jach.hawaii.edu/jcmt\_sw/perl).}


Character arrays can be dealt with as follows:

\begin{myquote}
\begin{verbatim}
$mapped_string = pack("A20" x ($#data +1), @data);
ndf_map($indf, 'DATA', '_CHARACTER*20', 'WRITE', $pntr, $el, $status);
string2mem($mapped_string, 20*($#data +1), $pntr);
\end{verbatim}
\end{myquote}
% $ 

This packs an array of perl strings into a fixed length (space padded) string
of length 20 $\times$ (size of array) characters. The string is then copied to
the mapped array with \texttt{string2mem}.

Dealing with arrays is made easier by the \texttt{array2mem} and
\texttt{mem2array}  routines, which handle the packing for the programmer. At
present these routines do not work with character arrays and the lower level
\texttt{string2mem} and \texttt{mem2string} routines must still be used.

To copy from a mapped array to a perl array you use \texttt{mem2array}. The
routine requires the pointer to the mapped array, the pack type (as used in
the the perl {\tt pack} command, i.e. "i$\ast$" for ints, "f$\ast$" for
floats) and the number of elements, and returns the array.

For example:
\begin{myquote}
\begin{verbatim}
ndf_map($indf, 'DATA', '_INTEGER', 'READ', $pntr, $el, $status);
@data = mem2array($pntr, "i*", $el);
\end{verbatim}
\end{myquote}


To write to a mapped array, you use \texttt{array2mem}:

\begin{myquote}
\begin{verbatim}
ndf_map($indf, 'DATA', '_INTEGER', 'WRITE', $pntr, $el, $status);
array2mem(@data, "i*", $pntr);
\end{verbatim}
\end{myquote}
% $

Remember that, at present, these routines {\em do not\/} work with
\underscore{}CHARACTER arrays. In that case you must use the
\texttt{mem2string}  and \texttt{string2mem} routines directly.

\subsection{Accessing FITS entries}%
\index{Accessing FITS entries}

FITS entries are stored in the FITS extension of an NDF. The FITS array
can be accessed by using raw HDS commands as follows:

\begin{myquote}
\begin{verbatim}
ndf_xloc($indf, 'FITS', 'READ', $floc, $status);
dat_get1c($floc, 200, @fits, $nfits, $status);
\end{verbatim}
\end{myquote}

(The 200 indicates the maximum size of the array --- this can be any
value greater than or equal to the actual size of the array and can be
determined beforehand by using the \texttt{dat\_size} command).  The FITS
header information is now in the perl \texttt{@fits} array and can be accessed
via fits\underscore{}get\underscore{}item and fits\underscore{}get\underscore{}nth\underscore{}item.

For example, to list all the values and keywords:

\begin{myquote}
\begin{verbatim}
for ($i=0; $i <= $#fits; $i++) {
  ($keyword, $value, $comment) = fits_get_nth_item(@fits, $i);
  print "$i: $keyword\t $value\n";
}
\end{verbatim}
\end{myquote}
% $

You can also use fits\underscore{}extract\underscore{}key\underscore{}val to
access the nth entry via

\begin{myquote}
\begin{verbatim}
($keyword, $value, $comment) = fits_extract_key_val($fits[$n]);
\end{verbatim}
\end{myquote}
% $ 

To find out the value that goes with a keyword:

\begin{myquote}
\begin{verbatim}
$inst = fits_get_item(@fits, 'INSTRUME');
print "Instrument is $inst\n";
\end{verbatim}
\end{myquote}

Remember that perl has associative arrays, such that
\begin{myquote}
\begin{verbatim}
%fitsitem = ();
for ($i=0; $i <= $#fits; $i++) {
  ($keyword, $value, $comment) = fits_get_nth_item(@fits, $i);
  $fitsitem{$keyword} = $value;
}
\end{verbatim}
\end{myquote}

So that {\tt 'print "\$fitsitem\{'INSTRUME'\}\char`\\n";'} will print, say,
SCUBA.

A general routine exists for reading the FITS
header. fits\underscore{}read\underscore{}header reads the FITS extension and
returns the reference to a hash array:

\begin{myquote}
\begin{verbatim}
($hashref, $status) = fits_read_header($file);
\end{verbatim}
\end{myquote}
% $

The FITS entries can then be accessed as \$\$hashref\{'ITEM'\}.
This takes the filename as an argument and returns the Starlink status.

\subsection{Accessing ADAM parameters from A-tasks}%
\index{Accessing ADAM parameters from A-tasks}

ADAM A-tasks store their parameters in HDS files in the ADAM\underscore{}USER
directory (usually $\tilde{\hspace{0.4em}}$/adam). This routine retrieves the
value of a parameter for any ADAM task that uses the ADAM\underscore{}USER
directory and is based on the \Kappa\ task \parget.

For example
\begin{myquote}
\begin{verbatim}
($in) = par_get("data_array","GLOBAL", \$status);
\end{verbatim}
\end{myquote}

returns the current data set (stored in GLOBAL.sdf). Note that the 
data is returned in an array context. The routine returns without
action if \$status is not set to SAI\underscore{}\underscore{}OK on entry. 
Note that a reference to \$status is passed into this routine so that the
status can be modified on exit.


Either the \$ADAM\underscore{}USER or \$HOME environment variable must be set
so that the location of the parameter files can be determined.

This command can not access parameter values of tasks that are currently
running. In order to retrieve parameter values via the ADAM messaging system
the Starlink::ADAMTASK module must be used\footnote{Please contact the author
for more information on the Starlink::ADAMTASK module.}.


\subsection{NOTES}

\subsubsection{Function calls}%
\index{Function calls}

The commands in this module use  perl prototypes to check argument 
passing. This means that arrays do not have to be referenced when being
used as arguments {\em unless\/} the routine is called with a \&.

For example, both

\begin{myquote}
\begin{verbatim}
$value = fits_get_item(@fits, $keyword);
\end{verbatim}
\end{myquote}
and
\begin{myquote}
\begin{verbatim}
$value = &fits_get_item(\@fits, $keyword);
\end{verbatim}
\end{myquote}

are correct but
\begin{myquote} 
\begin{verbatim}
$value = &fits_get_item(@fits, $keyword);
\end{verbatim}
\end{myquote}

will fail because perl will pass all the members of the array and not the
reference to the array. 

\subsubsection{Arrays}%
\index{Arrays}

Note that the GetNx/PutNx routines have not been implemented in this module
because plain Perl does not really support N-dimensional arrays.  All data in
plain perl is vectorised.  If you wish to use N-dimensional data structures in
perl you must use the
\htmladdnormallinkfoot{PDL}{http://www.aao.gov.au/local/www/kgb/perldl/} module
in conjunction with a vectorised read. (see eg. the \texttt{rndf} command in
\texttt{perldl} which stores all arrays as true N-dimensional data sets). The
PDL module is available from
\htmladdnormallinkfoot{CPAN}{http://www.perl.com/CPAN/}. Also note that the
Get1x/Put1x routines are implemented but are not necessary since the
vectorised routines can always be used instead.

\subsubsection{Accessing TYPEd data}%
\index{Accessing TYPEd data}

Although routines are available for accessing data of any type (eg
\_INTEGER, \_REAL, \_DOUBLE) the untyped nature of perl and the type conversion
inherent in the NDF routines mean that, in practice, only character handling
routines are needed to access data (eg via \texttt{ndf\underscore{}xgt0c} or
\texttt{dat\underscore{}get1c}). This does not apply to mapped data arrays
where the size of the data type must be known before unpacking. The double
precision routines may be necessary since the type conversion routines
truncate to \_REAL precision when converting to \_CHAR.

\subsubsection{Printing History information}%
\index{Printing History information}

Whilst all the NDF history calls are implemented, NDF\underscore{}HOUT has
only a minimal functionality since NDF\underscore{}HOUT requires the name of a
Fortran subroutine.  Calling a perl subroutine from Fortran has not been
implemented and NDF\underscore{}HECHO is called by default.


\appendix

\section{\xlabel{subsys}NDFPERL sub-systems\label{subsys}}

This section lists name of each sub-system that can be imported via the 
perl \texttt{use} command. By default all sub-systems are loaded into the
current namespace.

\begin{description}

\item[:ndf]%
\index{:ndf@:ndf}%
\hfil\\
This imports all the NDF\underscore{} functions for use.

\item[:msg]%
\index{:msg@:msg}%
\hfil\\
This imports all the MSG\underscore{} functions.

\item[:err]%
\index{:err@:err}%
\hfil\\
This imports all the Starlink error handling functions (ERR\underscore{})

\item[:ary]%
\index{:ary@:ary}%
\hfil\\
This imports some ARY\underscore{} functions.

\item[:hds]%
\index{:hds@:hds}%
\hfil\\
This imports the HDS\underscore{} functions

\item[:dat]%
\index{:dat@:dat}%
\hfil\\
This imports most of the  DAT\underscore{} functions

\item[:cmp]%
\index{:cmp@:cmp}%
\hfil\\
This imports most of the CMP\underscore{} functions

\item[:misc]%
\index{:misc@:misc}%
\hfil\\
This imports routines for converting DATA pointers to arrays and routines for 
easy access to FITS arrays commonly found in NDFs. A routine for accessing
parameters stored by ADAM tasks is also available.

\end{description}


\section{Implemented routines}%
\index{Implemented routines}

This section lists all the routines that are available from within this module.

The command syntax for these commands can be found in the documentation
for each library (\ndf, \hds, \mers and \ary).

\begin{description}

\item[:ndf]%
\index{:ndf@:ndf}%
\hfil\\
All ndf\underscore{} routines are implemented except those dealing with ADAM parameters
(eg ndf\underscore{}assoc). 

\item[:ary]%
\index{:ary@:ary}%
\hfil\\
ary\underscore{}annul ary\underscore{}dim ary\underscore{}find ary\underscore{}map ary\underscore{}ndim ary\underscore{}size ary\underscore{}unmap

\item[:msg]%
\index{:msg@:msg}%
\hfil\\
All msg\underscore{} routines are implemented:
msg\underscore{}bell msg\underscore{}blank msg\underscore{}fmtc msg\underscore{}fmtd msg\underscore{}fmti msg\underscore{}fmtl msg\underscore{}fmtr
msg\underscore{}iflev msg\underscore{}ifset msg\underscore{}load msg\underscore{}out msg\underscore{}outif msg\underscore{}renew msg\underscore{}setc
msg\underscore{}setd msg\underscore{}seti msg\underscore{}setl msg\underscore{}setr

\item[:err]%
\index{:err@:err}%
\hfil\\
All err\underscore{} routines are implemented:
err\underscore{}annul err\underscore{}begin err\underscore{}end err\underscore{}facer err\underscore{}fioer err\underscore{}flbel err\underscore{}flush
err\underscore{}level err\underscore{}load err\underscore{}mark err\underscore{}rep err\underscore{}rlse err\underscore{}stat err\underscore{}syser

\item[:hds]%
\index{:hds@:hds}%
\hfil\\
All hds\underscore{} routines are implemented:
hds\underscore{}copy hds\underscore{}erase hds\underscore{}ewild hds\underscore{}flush hds\underscore{}free hds\underscore{}group hds\underscore{}gtune
hds\underscore{}link hds\underscore{}lock hds\underscore{}new hds\underscore{}open hds\underscore{}show hds\underscore{}state hds\underscore{}stop
hds\underscore{}trace hds\underscore{}tune hds\underscore{}wild

\item[:dat]%
\index{:dat@:dat}%
\hfil\\
dat\underscore{}alter dat\underscore{}annul dat\underscore{}basic dat\underscore{}ccopy dat\underscore{}cctyp dat\underscore{}cell dat\underscore{}clen
dat\underscore{}clone dat\underscore{}coerc dat\underscore{}copy dat\underscore{}drep dat\underscore{}erase dat\underscore{}ermsg dat\underscore{}find
dat\underscore{}get0c dat\underscore{}get0d dat\underscore{}get0i dat\underscore{}get0l dat\underscore{}get0r dat\underscore{}get1c dat\underscore{}get1d
dat\underscore{}get1i dat\underscore{}get1r dat\underscore{}getvc dat\underscore{}getvd dat\underscore{}getvi dat\underscore{}getvr dat\underscore{}index
dat\underscore{}len dat\underscore{}map dat\underscore{}mapc dat\underscore{}mapd dat\underscore{}mapi dat\underscore{}mapl dat\underscore{}mapr dat\underscore{}mapv
dat\underscore{}mould dat\underscore{}move dat\underscore{}msg dat\underscore{}name dat\underscore{}ncomp dat\underscore{}new dat\underscore{}new0c
dat\underscore{}new0d dat\underscore{}new0i dat\underscore{}new0l dat\underscore{}new0r dat\underscore{}new1c dat\underscore{}new1d dat\underscore{}new1i
dat\underscore{}new1l dat\underscore{}new1r dat\underscore{}newc dat\underscore{}paren dat\underscore{}prec dat\underscore{}prim dat\underscore{}prmry
dat\underscore{}put0c dat\underscore{}put0d dat\underscore{}put0d dat\underscore{}put0l dat\underscore{}put0r dat\underscore{}put1c dat\underscore{}put1d
dat\underscore{}put1i dat\underscore{}put1r dat\underscore{}putd dat\underscore{}puti dat\underscore{}putr dat\underscore{}putvc dat\underscore{}putvd
dat\underscore{}putvi dat\underscore{}putvr dat\underscore{}ref dat\underscore{}refct dat\underscore{}renam dat\underscore{}reset dat\underscore{}retyp
dat\underscore{}shape dat\underscore{}size dat\underscore{}slice dat\underscore{}state dat\underscore{}struc dat\underscore{}temp dat\underscore{}there
dat\underscore{}type dat\underscore{}unmap dat\underscore{}valid dat\underscore{}vec dat\underscore{}where

\item[:cmp]%
\index{:cmp@:cmp}%
\hfil\\
cmp\underscore{}get0c cmp\underscore{}get0d cmp\underscore{}get0i cmp\underscore{}get0l cmp\underscore{}get0r cmp\underscore{}get1c cmp\underscore{}get1d
cmp\underscore{}get1i cmp\underscore{}get1r cmp\underscore{}getvc cmp\underscore{}getvd cmp\underscore{}getvi cmp\underscore{}getvr cmp\underscore{}len
cmp\underscore{}mapv cmp\underscore{}mod cmp\underscore{}modc cmp\underscore{}prim cmp\underscore{}put0c cmp\underscore{}put0d cmp\underscore{}put0i
cmp\underscore{}put0l cmp\underscore{}put0r cmp\underscore{}put1c cmp\underscore{}put1d cmp\underscore{}put1i cmp\underscore{}put1r cmp\underscore{}putni
cmp\underscore{}putvc cmp\underscore{}putvd cmp\underscore{}putvi cmp\underscore{}putvr cmp\underscore{}shape cmp\underscore{}size cmp\underscore{}struc
cmp\underscore{}type cmp\underscore{}unmap

\item[:misc]%
\index{:misc@:misc}%
\hfil\\
mem2string string2mem array2mem mem2array fits\underscore{}get\underscore{}nth\underscore{}item
fits\underscore{}read\underscore{}header fits\underscore{}get\underscore{}item fits\underscore{}extract\underscore{}key\underscore{}val 
fits\underscore{}construct\underscore{}string par\underscore{}get

\end{description}


	
% ? End of main text 
\end{document}
